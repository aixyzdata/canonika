<template>
  <div class="canonika-view">
    <!-- View Header seguindo padrão das outras views -->
    <div class="view-header">
      <div class="view-title">
        <i class="fas fa-broadcast-tower"></i>
        <div class="title-content">
          <h1>WebSocket</h1>
          <p>Conexão Real-time</p>
        </div>
      </div>
      <div class="view-status">
        <div class="status-indicator" :class="statusIndicatorClass"></div>
        <span>{{ statusText }}</span>
      </div>
      <div class="view-actions">
        <button 
          class="btn btn-primary btn-sm" 
          @click="connect"
          :disabled="!canConnect || isConnecting"
        >
          <i class="fas fa-plug me-2"></i>
          {{ isConnecting ? 'Conectando...' : 'Conectar' }}
        </button>
        <button 
          class="btn btn-secondary btn-sm" 
          @click="disconnect"
          :disabled="!canDisconnect || isDisconnecting"
        >
          <i class="fas fa-times me-2"></i>
          {{ isDisconnecting ? 'Desconectando...' : 'Desconectar' }}
        </button>
        <button 
          class="btn btn-success btn-sm" 
          @click="sendTestMessage"
          :disabled="connectionStatus !== 'connected'"
        >
          <i class="fas fa-paper-plane me-2"></i>
          Teste
        </button>
      </div>
    </div>

    <!-- View Content -->
    <div class="view-content">
      <!-- Seção: Status da Conexão -->
      <div class="canonika-section">
        <div class="section-header">
          <h3 class="section-title">
            <i class="fas fa-signal text-success me-2"></i>
            Status da Conexão
          </h3>
          <p class="section-description">
            Monitoramento em tempo real da conexão WebSocket.
          </p>
        </div>
        
        <div class="section-content">
          <div class="service-cards">
            <div class="service-card">
              <div class="card-header">
                <div class="card-icon">
                  <i class="fas fa-broadcast-tower"></i>
                </div>
                <div class="card-title">
                  <h4>Conexão WebSocket</h4>
                  <span class="card-subtitle">ws://localhost:3703/ws</span>
                </div>
                <div class="card-actions">
                  <span class="status-badge" :class="statusIndicatorClass">{{ statusText }}</span>
                </div>
              </div>
              <div class="card-content">
                <div class="metric-grid">
                  <div class="metric-item">
                    <span class="metric-value">{{ connectionStatus.toUpperCase() }}</span>
                    <span class="metric-label">Estado</span>
                  </div>
                  <div class="metric-item">
                    <span class="metric-value">{{ metrics.latency }}ms</span>
                    <span class="metric-label">Latência</span>
                  </div>
                  <div class="metric-item">
                    <span class="metric-value">{{ metrics.uptime }}</span>
                    <span class="metric-label">Uptime</span>
                  </div>
                </div>
              </div>
            </div>

            <div class="service-card">
              <div class="card-header">
                <div class="card-icon">
                  <i class="fas fa-chart-line"></i>
                </div>
                <div class="card-title">
                  <h4>Métricas</h4>
                  <span class="card-subtitle">Performance</span>
                </div>
                <div class="card-actions">
                  <span class="status-badge" :class="connectionStatus === 'connected' ? 'online' : 'offline'">
                    {{ connectionStatus === 'connected' ? 'Ótima' : 'Indisponível' }}
                  </span>
                </div>
              </div>
              <div class="card-content">
                <div class="metric-grid">
                  <div class="metric-item">
                    <span class="metric-value">{{ metrics.messagesPerMinute }}</span>
                    <span class="metric-label">Mensagens/min</span>
                  </div>
                  <div class="metric-item">
                    <span class="metric-value">{{ metrics.deliveryRate }}%</span>
                    <span class="metric-label">Delivery Rate</span>
                  </div>
                  <div class="metric-item">
                    <span class="metric-value">{{ metrics.avgResponse }}ms</span>
                    <span class="metric-label">Avg Response</span>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Seção: Eventos em Tempo Real -->
      <div class="canonika-section">
        <div class="section-header">
          <h3 class="section-title">
            <i class="fas fa-bell text-warning me-2"></i>
            Eventos em Tempo Real
          </h3>
          <p class="section-description">
            Últimos eventos recebidos via WebSocket.
          </p>
        </div>
        
        <div class="section-content">
          <div class="info-cards">
            <div class="info-card">
              <div class="info-label">Último Evento</div>
              <div class="info-value">{{ events.length > 0 ? events[0].type : 'Nenhum' }}</div>
              <div class="info-description">{{ events.length > 0 ? 'Há alguns segundos' : 'Aguardando eventos' }}</div>
            </div>
            
            <div class="info-card">
              <div class="info-label">Total Eventos</div>
              <div class="info-value">{{ events.length }}</div>
              <div class="info-description">Recebidos</div>
            </div>
            
            <div class="info-card">
              <div class="info-label">Tópicos Ativos</div>
              <div class="info-value">{{ topics.length }}</div>
              <div class="info-description">Inscritos</div>
            </div>
            
            <div class="info-card">
              <div class="info-label">Connection ID</div>
              <div class="info-value">{{ connectionId || 'N/A' }}</div>
              <div class="info-description">ID da conexão</div>
            </div>
          </div>
        </div>
      </div>



      <!-- Seção: Testes WebSocket -->
      <div class="canonika-section">
        <div class="section-header">
          <h3 class="section-title">
            <i class="fas fa-vial text-warning me-2"></i>
            Testes WebSocket
          </h3>
          <p class="section-description">
            Execute testes automatizados para validar a conectividade e funcionalidade do WebSocket.
          </p>
        </div>
        
        <div class="section-content">
          <!-- Configurações do Teste -->
          <div class="test-config">
            <div class="config-row">
              <div class="config-item">
                <label for="messageCount">Quantidade de Mensagens:</label>
                <input 
                  id="messageCount"
                  v-model.number="testConfig.messageCount" 
                  type="number" 
                  min="1" 
                  max="1000"
                  class="form-control"
                  :disabled="isTestRunning"
                >
              </div>
              
              <div class="config-item">
                <label for="testType">Tipo de Teste:</label>
                <select 
                  id="testType"
                  v-model="testConfig.testType" 
                  class="form-control"
                  :disabled="isTestRunning"
                >
                  <option value="random">Mensagens Aleatórias</option>
                  <option value="sequential">Mensagens Sequenciais</option>
                  <option value="json">JSON Complexo</option>
                  <option value="error_simulation">Simulação de Erros</option>
                </select>
              </div>
              
              <div class="config-item">
                <label for="topic">Tópico:</label>
                <input 
                  id="topic"
                  v-model="testConfig.topic" 
                  type="text" 
                  class="form-control"
                  placeholder="test"
                  :disabled="isTestRunning"
                >
              </div>
              
              <div class="config-item">
                <label for="delayMs">Delay (ms):</label>
                <input 
                  id="delayMs"
                  v-model.number="testConfig.delayMs" 
                  type="number" 
                  min="100" 
                  max="10000"
                  class="form-control"
                  :disabled="isTestRunning"
                >
              </div>
            </div>
            
            <div class="test-actions">
              <button 
                @click="startTest"
                :disabled="!canStartTest || isTestRunning"
                class="btn btn-primary"
              >
                <i class="fas fa-play me-2"></i>
                {{ isTestRunning ? 'Teste em Execução...' : 'Iniciar Teste' }}
              </button>
              
              <button 
                @click="stopTest"
                :disabled="!isTestRunning"
                class="btn btn-danger"
              >
                <i class="fas fa-stop me-2"></i>
                Parar Teste
              </button>
              
              <button 
                @click="clearTestLog"
                :disabled="testLog.length === 0"
                class="btn btn-secondary"
              >
                <i class="fas fa-trash me-2"></i>
                Limpar Log
              </button>
            </div>
          </div>

          <!-- Status do Teste -->
          <div v-if="currentTest || isTestRunning" class="test-status">
            <div class="status-info">
              <div class="status-item">
                <span class="status-label">Status:</span>
                <span class="status-value" :class="currentTest.status">{{ getStatusText(currentTest.status) }}</span>
              </div>
              <div class="status-item">
                <span class="status-label">Progresso:</span>
                <span class="status-value">{{ Math.round((currentTest && currentTest.progress) || 0) }}%</span>
              </div>
              <div class="status-item">
                <span class="status-label">Enviadas:</span>
                <span class="status-value">{{ (currentTest && currentTest.sent_count) || 0 }} / {{ (currentTest && currentTest.total_count) || 0 }}</span>
              </div>
            </div>
            
            <div class="progress-bar">
              <div 
                class="progress-fill" 
                :style="{ width: ((currentTest && currentTest.progress) || 0) + '%' }"
                :class="currentTest ? currentTest.status : 'running'"
              ></div>
            </div>
          </div>

          <!-- Terminal de Teste -->
          <div class="test-terminal">
            <div class="terminal-header">
              <span class="terminal-title">
                <i class="fas fa-terminal me-2"></i>
                Terminal de Teste
              </span>
              <span class="terminal-status">
                {{ testLog.length }} mensagens recebidas
              </span>
            </div>
            
            <div class="terminal-content" ref="terminalContent">
              <div 
                v-for="(log, index) in testLog" 
                :key="index"
                class="log-entry"
                :class="getLogEntryClass(log)"
              >
                <div class="log-timestamp">
                  {{ new Date(log.timestamp).toLocaleTimeString() }}
                </div>
                <div class="log-type">
                  [{{ log.type }}]
                </div>
                <div class="log-message">
                  {{ formatLogMessage(log) }}
                </div>
              </div>
              
              <div v-if="testLog.length === 0" class="no-logs">
                <i class="fas fa-info-circle"></i>
                Nenhuma mensagem de teste recebida ainda.
              </div>
            </div>
          </div>

          <!-- Seção: Download com Progresso -->
          <div class="canonika-section">
            <div class="section-header">
              <h3 class="section-title">
                <i class="fas fa-download text-success me-2"></i>
                Download com Progresso
              </h3>
              <p class="section-description">
                Simula downloads reais com progresso em tempo real via WebSocket.
              </p>
            </div>
            
            <div class="section-content">
              <!-- Configuração do Download -->
              <div class="download-config">
                <div class="config-grid">
                  <div class="config-item">
                    <label for="filename">Nome do Arquivo:</label>
                    <input 
                      id="filename"
                      v-model="downloadConfig.filename" 
                      type="text" 
                      class="form-control"
                      placeholder="arquivo.zip"
                      :disabled="isDownloadRunning"
                    >
                  </div>
                  
                  <div class="config-item">
                    <label for="fileSize">Tamanho (MB):</label>
                    <input 
                      id="fileSize"
                      v-model.number="downloadConfig.fileSize" 
                      type="number" 
                      min="1" 
                      max="1000"
                      class="form-control"
                      :disabled="isDownloadRunning"
                    >
                  </div>
                  
                  <div class="config-item">
                    <label for="downloadSpeed">Velocidade (MB/s):</label>
                    <input 
                      id="downloadSpeed"
                      v-model.number="downloadConfig.downloadSpeed" 
                      type="number" 
                      min="1" 
                      max="100"
                      class="form-control"
                      :disabled="isDownloadRunning"
                    >
                  </div>
                </div>
                
                <div class="download-actions">
                  <button 
                    @click="startDownload"
                    :disabled="!canStartDownload || isDownloadRunning"
                    class="btn btn-success"
                  >
                    <i class="fas fa-download me-2"></i>
                    {{ isDownloadRunning ? 'Download em Execução...' : 'Iniciar Download' }}
                  </button>
                  
                  <button 
                    @click="cancelDownload"
                    :disabled="!canCancelDownload"
                    class="btn btn-danger"
                  >
                    <i class="fas fa-times me-2"></i>
                    Cancelar Download
                  </button>
                  
                  <button 
                    @click="clearDownloadLog"
                    :disabled="downloadLog.length === 0"
                    class="btn btn-secondary"
                  >
                    <i class="fas fa-trash me-2"></i>
                    Limpar Log
                  </button>
                </div>
              </div>

              <!-- Status do Download -->
              <div v-if="currentDownload" class="download-status">
                <div class="status-info">
                  <div class="status-item">
                    <span class="status-label">Status:</span>
                    <span class="status-value" :class="currentDownload.status">{{ getStatusText(currentDownload.status) }}</span>
                  </div>
                  <div class="status-item">
                    <span class="status-label">Progresso:</span>
                    <span class="status-value">{{ Math.round(currentDownload.progress || 0) }}%</span>
                  </div>
                  <div class="status-item">
                    <span class="status-label">Baixado:</span>
                    <span class="status-value">{{ formatBytes(currentDownload.bytes_downloaded || 0) }} / {{ formatBytes(currentDownload.file_size_bytes || 0) }}</span>
                  </div>
                  <div class="status-item" v-if="currentDownload.eta > 0">
                    <span class="status-label">ETA:</span>
                    <span class="status-value">{{ formatTime(currentDownload.eta) }}</span>
                  </div>
                </div>
                
                <div class="progress-bar">
                  <div 
                    class="progress-fill" 
                    :style="{ width: (currentDownload.progress || 0) + '%' }"
                    :class="currentDownload.status"
                  ></div>
                </div>
              </div>

              <!-- Terminal de Download -->
              <div class="download-terminal">
                <div class="terminal-header">
                  <span class="terminal-title">
                    <i class="fas fa-terminal me-2"></i>
                    Terminal de Download
                  </span>
                  <span class="terminal-status">
                    {{ downloadLog.length }} mensagens
                  </span>
                </div>
                
                <div class="terminal-content" ref="downloadTerminalContent">
                  <div 
                    v-for="log in downloadLog" 
                    :key="log.timestamp"
                    class="log-entry"
                    :class="getLogEntryClass(log)"
                  >
                    <div class="log-header">
                      <span class="log-timestamp">{{ new Date(log.timestamp).toLocaleTimeString() }}</span>
                      <span class="log-type">{{ log.type.toUpperCase() }}</span>
                    </div>
                    <div class="log-message">
                      {{ formatLogMessage(log) }}
                    </div>
                  </div>
                  
                  <div v-if="downloadLog.length === 0" class="no-logs">
                    <i class="fas fa-info-circle"></i>
                    Nenhum download iniciado ainda.
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Seção: Log de Eventos -->
          <div class="canonika-section" v-if="events.length > 0">
            <div class="section-header">
              <h3 class="section-title">
                <i class="fas fa-list text-info me-2"></i>
                Log de Eventos
              </h3>
              <p class="section-description">
                Detalhes das chamadas e eventos recebidos.
              </p>
            </div>
            
            <div class="section-content">
              <div class="event-summary">
                <div class="summary-stats">
                  <div class="stat-item">
                    <span class="stat-label">Total de Eventos:</span>
                    <span class="stat-value">{{ events.length }}</span>
                  </div>
                  <div class="stat-item">
                    <span class="stat-label">Último Evento:</span>
                    <span class="stat-value">{{ events.length > 0 ? new Date(events[0].timestamp).toLocaleTimeString() : 'N/A' }}</span>
                  </div>
                  <div class="stat-item">
                    <span class="stat-label">Tipos de Evento:</span>
                    <span class="stat-value">{{ getUniqueEventTypes().join(', ') }}</span>
                  </div>
                </div>
                
                <div class="event-details" v-if="events.length > 0">
                  <h4>Último Evento Recebido:</h4>
                  <div class="event-detail-item">
                    <strong>Tipo:</strong> {{ events[0].type }}
                  </div>
                  <div class="event-detail-item">
                    <strong>Timestamp:</strong> {{ new Date(events[0].timestamp).toLocaleString() }}
                  </div>
                  <div class="event-detail-item" v-if="events[0].data">
                    <strong>Dados:</strong>
                    <pre class="event-data-preview">{{ JSON.stringify(events[0].data, null, 2) }}</pre>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Estatísticas do Teste -->
          <div v-if="testStats.totalMessages > 0" class="test-stats">
            <div class="stats-grid">
              <div class="stat-item">
                <div class="stat-value">{{ testStats.totalMessages }}</div>
                <div class="stat-label">Total de Mensagens</div>
              </div>
              <div class="stat-item">
                <div class="stat-value">{{ testStats.successRate }}%</div>
                <div class="stat-label">Taxa de Sucesso</div>
              </div>
              <div class="stat-item">
                <div class="stat-value">{{ testStats.avgLatency }}ms</div>
                <div class="stat-label">Latência Média</div>
              </div>
              <div class="stat-item">
                <div class="stat-value">{{ testStats.errors }}</div>
                <div class="stat-label">Erros</div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
import WebSocketService from '../services/WebSocketService.js'
import AuthService from '/app/shared/services/AuthService.js'

export default {
  name: 'WebSocketView',
  data() {
    return {
      wsService: WebSocketService,
      connectionStatus: 'disconnected',
      connectionId: null,
      metrics: {
        messagesPerMinute: 0,
        deliveryRate: 0,
        avgResponse: 0,
        latency: 0,
        uptime: '0s'
      },
      events: [],
      topics: [],
      isConnecting: false,
      isDisconnecting: false,
      
      // Teste WebSocket
      testConfig: {
        messageCount: 10,
        testType: 'random',
        topic: 'test',
        delayMs: 1000
      },
      downloadConfig: {
        filename: 'arquivo.zip',
        fileSize: 100,
        downloadSpeed: 10
      },
      currentTest: null,
      currentDownload: null,
      isTestRunning: false,
      isDownloadRunning: false,
      testLog: [],
      downloadLog: [],
      testStats: {
        totalMessages: 0,
        successRate: 0,
        avgLatency: 0,
        errors: 0
      },
      downloadStats: {
        totalDownloads: 0,
        completedDownloads: 0,
        cancelledDownloads: 0
      },
      statusPollingInterval: null
    }
  },
  async mounted() {
    console.log('📡 WebSocketView carregada')
    await this.initializeWebSocket()
  },
  beforeUnmount() {
    this.cleanup()
  },
  methods: {
    async initializeWebSocket() {
      try {
        // Obter token de autenticação
        const token = localStorage.getItem('canonika_access_token')
        if (!token) {
          console.error('Token não encontrado')
          return
        }

        // Configurar listeners
        this.setupWebSocketListeners()
        
        // Conectar automaticamente
        await this.connect()
        
      } catch (error) {
        console.error('Erro ao inicializar WebSocket:', error)
      }
    },

    setupWebSocketListeners() {
      // Listener para status de conexão
      this.wsService.onConnectionChange((status) => {
        this.connectionStatus = status
        console.log('Status da conexão:', status)
      })

      // Listener para métricas
      this.wsService.onMetricsUpdate((metrics) => {
        this.metrics = { ...this.metrics, ...metrics }
      })

      // Listener para eventos
      this.wsService.subscribe('events', (event) => {
        this.events.unshift(event)
        if (this.events.length > 50) {
          this.events.pop()
        }
      })

      // Listener para tópicos
      this.wsService.subscribe('topics', (topic) => {
        if (!this.topics.includes(topic)) {
          this.topics.push(topic)
        }
      })

      // Listener para downloads
      this.wsService.subscribe('downloads', (downloadData) => {
        this.handleDownloadMessage(downloadData)
      })
    },

    async connect() {
      if (this.isConnecting) return
      
      this.isConnecting = true
      try {
        const token = localStorage.getItem('canonika_access_token')
        await this.wsService.connect(token)
        
        // Aguardar confirmação de conexão
        await this.waitForConnection()
        
        // Inscrever em tópicos padrão
        await this.subscribeToDefaultTopics()
        
      } catch (error) {
        console.error('Erro ao conectar:', error)
        this.connectionStatus = 'error'
      } finally {
        this.isConnecting = false
      }
    },

    async disconnect() {
      if (this.isDisconnecting) return
      
      this.isDisconnecting = true
      try {
        this.wsService.disconnect()
        this.connectionStatus = 'disconnected'
        this.connectionId = null
      } catch (error) {
        console.error('Erro ao desconectar:', error)
      } finally {
        this.isDisconnecting = false
      }
    },

    async waitForConnection() {
      return new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
          reject(new Error('Timeout ao aguardar conexão'))
        }, 5000)

        const checkConnection = () => {
          if (this.wsService.isConnected) {
            clearTimeout(timeout)
            resolve()
          } else {
            setTimeout(checkConnection, 100)
          }
        }
        checkConnection()
      })
    },

    async subscribeToDefaultTopics() {
      const defaultTopics = ['system', 'notifications', 'metrics']
      
      for (const topic of defaultTopics) {
        try {
          await this.wsService.subscribe(topic, (data) => {
            console.log(`Mensagem do tópico ${topic}:`, data)
          })
        } catch (error) {
          console.error(`Erro ao inscrever no tópico ${topic}:`, error)
        }
      }
    },

    async sendTestMessage() {
      try {
        const testMessage = {
          type: 'test',
          data: {
            message: 'Teste de WebSocket',
            timestamp: new Date().toISOString()
          }
        }
        
        await this.wsService.send(testMessage)
        console.log('Mensagem de teste enviada')
      } catch (error) {
        console.error('Erro ao enviar mensagem de teste:', error)
      }
    },

    cleanup() {
      if (this.wsService) {
        // Cancelar todas as inscrições antes de desconectar
        if (this.testConfig.topic && this.testCallback) {
          this.wsService.unsubscribe(this.testConfig.topic, this.testCallback)
        } else if (this.testConfig.topic) {
          this.wsService.unsubscribe(this.testConfig.topic)
        }
        this.wsService.disconnect()
      }
      this.stopStatusPolling()
    },

    // Métodos de Teste WebSocket
    async startTest() {
      if (!this.wsService.isConnected) {
        this.addTestLog('error', 'WebSocket não está conectado. Conecte primeiro.')
        return
      }

      try {
        this.isTestRunning = true
        this.clearTestLog()
        
                        // O WebSocketService agora limpa automaticamente inscrições anteriores
                console.log('🔍 Iniciando teste com tópico:', this.testConfig.topic)
        
        // Inscrever no tópico de teste ANTES de iniciar o teste
        if (this.testConfig.topic) {
          console.log('🔍 Tópico configurado:', this.testConfig.topic)
          console.log('🔍 Inscrevendo no tópico:', this.testConfig.topic)
          
          // Criar callback e armazenar referência
          this.testCallback = (message) => {
            console.log('🔍 CALLBACK chamado para:', message.message, 'Timestamp:', new Date().toISOString())
            this.handleTestMessage(message)
          }
          
          await this.wsService.subscribe(this.testConfig.topic, this.testCallback)
          this.addTestLog('info', `Inscrito no tópico: ${this.testConfig.topic}`)
          
          // Pequeno delay para garantir que a inscrição seja processada
          await new Promise(resolve => setTimeout(resolve, 100))
        }
        
        // Iniciar teste no backend
        const response = await fetch('/api/test/websocket', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${localStorage.getItem('canonika_access_token')}`
          },
          body: JSON.stringify(this.testConfig)
        })

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`)
        }

        const result = await response.json()
        this.currentTest = {
          id: result.test_id,
          status: 'running',
          progress: 0,
          sent_count: 0,
          total_count: this.testConfig.messageCount
        }
        
        // Garantir que o progresso seja visível desde o início
        this.$nextTick(() => {
          if (this.currentTest) {
            this.currentTest.progress = 0
          }
        })

        this.addTestLog('info', `Teste iniciado: ${result.test_id}`)
        this.addTestLog('info', `Configuração: ${this.testConfig.messageCount} mensagens, tipo: ${this.testConfig.testType}, tópico: ${this.testConfig.topic}`)
        
        // Iniciar polling de status
        this.startStatusPolling()

      } catch (error) {
        console.error('Erro ao iniciar teste:', error)
        this.addTestLog('error', `Erro ao iniciar teste: ${error.message}`)
        this.isTestRunning = false
      }
    },

    async stopTest() {
      if (!this.currentTest) return

      try {
        const response = await fetch(`/api/test/stop/${this.currentTest.id}`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${localStorage.getItem('canonika_access_token')}`
          }
        })

        if (response.ok) {
          this.addTestLog('warning', 'Teste parado pelo usuário')
          this.currentTest.status = 'stopped'
        }
      } catch (error) {
        console.error('Erro ao parar teste:', error)
        this.addTestLog('error', `Erro ao parar teste: ${error.message}`)
      }
    },

    async startStatusPolling() {
      this.statusPollingInterval = setInterval(async () => {
        if (!this.currentTest || !this.isTestRunning) {
          this.stopStatusPolling()
          return
        }

        try {
          const response = await fetch(`/api/test/status/${this.currentTest.id}`, {
            headers: {
              'Authorization': `Bearer ${localStorage.getItem('canonika_access_token')}`
            }
          })

          if (response.ok) {
            const status = await response.json()
            
            // Atualizar apenas se o status não for 'completed', 'error' ou 'stopped'
            // para preservar o status final
            if (status.status && !['completed', 'error', 'stopped'].includes(status.status)) {
              this.currentTest = { ...this.currentTest, ...status }
            } else {
              // Para status finais, atualizar apenas outros campos, não o status
              const { status: backendStatus, ...otherFields } = status
              this.currentTest = { ...this.currentTest, ...otherFields }
            }

            // Verificar se teste foi concluído
            if (status.status === 'completed' || status.status === 'error' || status.status === 'stopped') {
              this.isTestRunning = false
              this.stopStatusPolling()
              this.updateTestStats()
              
              // Definir o status final
              this.currentTest.status = status.status
              
              if (status.status === 'completed') {
                this.addTestLog('success', 'Teste concluído com sucesso!')
              } else if (status.status === 'error') {
                this.addTestLog('error', 'Teste falhou com erros')
              }
            }
          }
        } catch (error) {
          console.error('Erro ao verificar status:', error)
        }
      }, 1000)
    },

    stopStatusPolling() {
      if (this.statusPollingInterval) {
        clearInterval(this.statusPollingInterval)
        this.statusPollingInterval = null
      }
    },

    handleTestMessage(message) {
      console.log('🔍 handleTestMessage chamado para:', message.message, 'Timestamp:', new Date().toISOString())
      const now = Date.now()
      const latency = now - (message.timestamp * 1000)
      
      this.addTestLog('message', message, latency)
      this.updateTestStats()
      
      // Atualizar contador de mensagens enviadas e progresso
      if (this.currentTest && message.type === 'test') {
        this.currentTest.sent_count = (this.currentTest.sent_count || 0) + 1
        this.currentTest.progress = Math.round((this.currentTest.sent_count / this.currentTest.total_count) * 100)
        
        // Se chegou a 100%, marcar como concluído
        if (this.currentTest.progress >= 100) {
          this.currentTest.status = 'completed'
          this.isTestRunning = false
          this.stopStatusPolling()
          this.addTestLog('success', 'Teste concluído com sucesso!')
        }
        
        // Log do progresso para debug
        console.log(`📊 Progresso atualizado: ${this.currentTest.sent_count}/${this.currentTest.total_count} = ${this.currentTest.progress}%`)
      }
    },

    addTestLog(type, message, latency = 0) {
      const logEntry = {
        type,
        message: typeof message === 'string' ? message : JSON.stringify(message, null, 2),
        timestamp: Date.now(),
        latency,
        raw: message
      }

      this.testLog.unshift(logEntry)
      
      // Limitar log a 1000 entradas
      if (this.testLog.length > 1000) {
        this.testLog = this.testLog.slice(0, 1000)
      }

      // Auto-scroll para o topo
      this.$nextTick(() => {
        if (this.$refs.terminalContent) {
          this.$refs.terminalContent.scrollTop = 0
        }
      })
    },

    clearTestLog() {
      this.testLog = []
      this.testStats = {
        totalMessages: 0,
        successRate: 0,
        avgLatency: 0,
        errors: 0
      }
    },

    updateTestStats() {
      const messages = this.testLog.filter(log => log.type === 'message')
      const errors = this.testLog.filter(log => log.type === 'error')
      const latencies = messages.map(log => log.latency).filter(lat => lat > 0)

      this.testStats = {
        totalMessages: messages.length,
        successRate: messages.length > 0 ? Math.round(((messages.length - errors.length) / messages.length) * 100) : 0,
        avgLatency: latencies.length > 0 ? Math.round(latencies.reduce((sum, lat) => sum + lat, 0) / latencies.length) : 0,
        errors: errors.length
      }
    },

    getLogEntryClass(log) {
      return {
        'log-message': log.type === 'message',
        'log-error': log.type === 'error',
        'log-warning': log.type === 'warning',
        'log-success': log.type === 'success',
        'log-info': log.type === 'info'
      }
    },

    formatLogMessage(log) {
      if (log.type === 'message' && log.raw && log.raw.data) {
        const data = log.raw.data
        if (typeof data === 'object') {
          if (data.text) return data.text
          if (data.error) return `ERRO: ${data.error}`
          return JSON.stringify(data, null, 2)
        }
      }
      return log.message
    },

    getStatusText(status) {
      const statusMap = {
        'running': 'Executando',
        'completed': 'Concluído',
        'error': 'Erro',
        'stopped': 'Parado'
      }
      return statusMap[status] || status
    },

    getUniqueEventTypes() {
      const types = [...new Set(this.events.map(event => event.type))]
      return types.slice(0, 5) // Limitar a 5 tipos para não ficar muito longo
    },

    // Métodos de Download
    async startDownload() {
      if (!this.wsService.isConnected) {
        this.addDownloadLog('error', 'WebSocket não está conectado. Conecte primeiro.')
        return
      }

      try {
        this.isDownloadRunning = true
        this.clearDownloadLog()
        
        // Iniciar download no backend
        const response = await fetch('/api/download/start', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${localStorage.getItem('canonika_access_token')}`
          },
          body: JSON.stringify(this.downloadConfig)
        })

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`)
        }

        const result = await response.json()
        this.currentDownload = {
          id: result.download_id,
          filename: this.downloadConfig.filename,
          status: 'running',
          progress: 0,
          bytes_downloaded: 0,
          file_size_bytes: this.downloadConfig.fileSize * 1024 * 1024,
          eta: result.estimated_time
        }

        this.downloadStats.totalDownloads++
        this.addDownloadLog('info', `Download iniciado: ${result.download_id}`)
        this.addDownloadLog('info', `Arquivo: ${this.downloadConfig.filename} (${this.downloadConfig.fileSize}MB)`)

      } catch (error) {
        console.error('Erro ao iniciar download:', error)
        this.addDownloadLog('error', `Erro ao iniciar download: ${error.message}`)
        this.isDownloadRunning = false
      }
    },

    async cancelDownload() {
      if (!this.currentDownload) return

      try {
        const response = await fetch(`/api/download/cancel/${this.currentDownload.id}`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${localStorage.getItem('canonika_access_token')}`
          }
        })

        if (response.ok) {
          this.addDownloadLog('warning', 'Download cancelado pelo usuário')
          this.currentDownload.status = 'cancelled'
          this.isDownloadRunning = false
        }
      } catch (error) {
        console.error('Erro ao cancelar download:', error)
        this.addDownloadLog('error', `Erro ao cancelar download: ${error.message}`)
      }
    },

    handleDownloadMessage(downloadData) {
      console.log('Download message received:', downloadData)
      
      switch (downloadData.type) {
        case 'download_progress':
          this.updateDownloadProgress(downloadData)
          break
        case 'download_completed':
          this.handleDownloadCompleted(downloadData)
          break
        case 'download_cancelled':
          this.handleDownloadCancelled(downloadData)
          break
      }
    },

    updateDownloadProgress(downloadData) {
      if (this.currentDownload && this.currentDownload.id === downloadData.download_id) {
        this.currentDownload = {
          ...this.currentDownload,
          progress: downloadData.progress,
          bytes_downloaded: downloadData.bytes_downloaded,
          eta: downloadData.eta
        }
      }

      this.addDownloadLog('progress', downloadData)
    },

    handleDownloadCompleted(downloadData) {
      if (this.currentDownload && this.currentDownload.id === downloadData.download_id) {
        this.currentDownload.status = 'completed'
        this.currentDownload.progress = 100
        this.isDownloadRunning = false
        this.downloadStats.completedDownloads++
      }

      this.addDownloadLog('success', `Download concluído: ${downloadData.filename} em ${downloadData.total_time}s`)
    },

    handleDownloadCancelled(downloadData) {
      if (this.currentDownload && this.currentDownload.id === downloadData.download_id) {
        this.currentDownload.status = 'cancelled'
        this.isDownloadRunning = false
        this.downloadStats.cancelledDownloads++
      }

      this.addDownloadLog('warning', `Download cancelado: ${downloadData.filename}`)
    },

    addDownloadLog(type, message, latency = 0) {
      const logEntry = {
        type,
        message: typeof message === 'string' ? message : JSON.stringify(message, null, 2),
        timestamp: Date.now(),
        latency,
        raw: message
      }

      this.downloadLog.unshift(logEntry)
      
      // Limitar log a 1000 entradas
      if (this.downloadLog.length > 1000) {
        this.downloadLog = this.downloadLog.slice(0, 1000)
      }

      // Auto-scroll para o topo
      this.$nextTick(() => {
        if (this.$refs.downloadTerminalContent) {
          this.$refs.downloadTerminalContent.scrollTop = 0
        }
      })
    },

    clearDownloadLog() {
      this.downloadLog = []
    },

    formatBytes(bytes) {
      if (bytes === 0) return '0 B'
      const k = 1024
      const sizes = ['B', 'KB', 'MB', 'GB']
      const i = Math.floor(Math.log(bytes) / Math.log(k))
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i]
    },

    formatTime(seconds) {
      if (seconds < 60) return `${Math.round(seconds)}s`
      if (seconds < 3600) return `${Math.floor(seconds / 60)}m ${Math.round(seconds % 60)}s`
      return `${Math.floor(seconds / 3600)}h ${Math.floor((seconds % 3600) / 60)}m`
    }
  },

  computed: {
    statusIndicatorClass() {
      return {
        'online': this.connectionStatus === 'connected',
        'offline': this.connectionStatus === 'disconnected',
        'warning': this.connectionStatus === 'connecting' || this.connectionStatus === 'error'
      }
    },

    statusText() {
      const statusMap = {
        'connected': 'Conectado',
        'disconnected': 'Desconectado',
        'connecting': 'Conectando...',
        'error': 'Erro de Conexão'
      }
      return statusMap[this.connectionStatus] || 'Desconhecido'
    },

    canConnect() {
      return this.connectionStatus === 'disconnected' && !this.isConnecting
    },

    canDisconnect() {
      return this.connectionStatus === 'connected' && !this.isDisconnecting
    },

    canStartTest() {
      return this.connectionStatus === 'connected' && !this.isTestRunning
    },

    canStartDownload() {
      return this.connectionStatus === 'connected' && !this.isDownloadRunning
    },

    canCancelDownload() {
      return this.isDownloadRunning && this.currentDownload && this.currentDownload.status === 'running'
    }
  }
}
</script>

<style scoped>
.event-log {
  max-height: 400px;
  overflow-y: auto;
  border: 1px solid #475569;
  border-radius: 0.5rem;
  background: rgba(30, 41, 59, 0.5);
}

.event-item {
  padding: 1rem;
  border-bottom: 1px solid #475569;
  transition: background-color 0.2s ease;
}

.event-item:last-child {
  border-bottom: none;
}

.event-item:hover {
  background: rgba(59, 130, 246, 0.1);
}

.event-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 0.5rem;
}

.event-type {
  font-weight: 600;
  color: #3b82f6;
  font-size: 0.875rem;
}

.event-time {
  color: #94a3b8;
  font-size: 0.75rem;
}

.event-data {
  background: rgba(0, 0, 0, 0.2);
  padding: 0.5rem;
  border-radius: 0.25rem;
  font-family: 'Courier New', monospace;
  font-size: 0.75rem;
  color: #e2e8f0;
  white-space: pre-wrap;
  word-break: break-all;
}

/* Teste WebSocket Styles */
.test-config {
  background: rgba(30, 41, 59, 0.5);
  border: 1px solid #475569;
  border-radius: 0.5rem;
  padding: 1.5rem;
  margin-bottom: 1.5rem;
}

.config-row {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 1rem;
  margin-bottom: 1.5rem;
}

.config-item {
  display: flex;
  flex-direction: column;
}

.config-item label {
  font-size: 0.875rem;
  font-weight: 600;
  color: #e2e8f0;
  margin-bottom: 0.5rem;
}

.config-item input,
.config-item select {
  background: rgba(0, 0, 0, 0.3);
  border: 1px solid #475569;
  border-radius: 0.25rem;
  padding: 0.5rem;
  color: #e2e8f0;
  font-size: 0.875rem;
}

.config-item input:focus,
.config-item select:focus {
  outline: none;
  border-color: #3b82f6;
  box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
}

.test-actions {
  display: flex;
  gap: 1rem;
  flex-wrap: wrap;
}

.test-status {
  background: rgba(30, 41, 59, 0.5);
  border: 1px solid #475569;
  border-radius: 0.5rem;
  padding: 1rem;
  margin-bottom: 1.5rem;
}

.status-info {
  display: flex;
  justify-content: space-between;
  margin-bottom: 1rem;
}

.status-item {
  display: flex;
  flex-direction: column;
  align-items: center;
}

.status-label {
  font-size: 0.75rem;
  color: #94a3b8;
  margin-bottom: 0.25rem;
}

.status-value {
  font-size: 1rem;
  font-weight: 600;
  color: #e2e8f0;
}

.status-value.running {
  color: #3b82f6;
}

.status-value.completed {
  color: #10b981;
}

.status-value.error {
  color: #ef4444;
}

.status-value.stopped {
  color: #f59e0b;
}

.progress-bar {
  width: 100%;
  height: 8px;
  background: rgba(0, 0, 0, 0.3);
  border-radius: 4px;
  overflow: hidden;
}

.progress-fill {
  height: 100%;
  background: linear-gradient(90deg, #3b82f6, #1d4ed8);
  transition: width 0.3s ease;
}

.progress-fill.completed {
  background: linear-gradient(90deg, #10b981, #059669);
}

.progress-fill.error {
  background: linear-gradient(90deg, #ef4444, #dc2626);
}

.progress-fill.stopped {
  background: linear-gradient(90deg, #f59e0b, #d97706);
}

.test-terminal {
  background: #1e293b;
  border: 1px solid #475569;
  border-radius: 0.5rem;
  overflow: hidden;
  margin-bottom: 1.5rem;
}

.terminal-header {
  background: #334155;
  padding: 0.75rem 1rem;
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-bottom: 1px solid #475569;
}

.terminal-title {
  font-weight: 600;
  color: #e2e8f0;
  font-size: 0.875rem;
}

.terminal-status {
  font-size: 0.75rem;
  color: #94a3b8;
}

.terminal-content {
  height: 400px;
  overflow-y: auto;
  padding: 1rem;
  font-family: 'Courier New', monospace;
  font-size: 0.75rem;
  line-height: 1.4;
}

.log-entry {
  display: flex;
  gap: 0.5rem;
  margin-bottom: 0.5rem;
  padding: 0.25rem 0;
  border-radius: 0.25rem;
  transition: background-color 0.2s ease;
}

.log-entry:hover {
  background: rgba(59, 130, 246, 0.1);
}

.log-timestamp {
  color: #94a3b8;
  min-width: 80px;
  font-size: 0.7rem;
}

.log-type {
  color: #3b82f6;
  min-width: 60px;
  font-weight: 600;
}

.log-message {
  color: #e2e8f0;
  flex: 1;
  word-break: break-word;
}

.log-entry.log-error .log-type {
  color: #ef4444;
}

.log-entry.log-warning .log-type {
  color: #f59e0b;
}

.log-entry.log-success .log-type {
  color: #10b981;
}

.log-entry.log-info .log-type {
  color: #06b6d4;
}

.no-logs {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 100%;
  color: #94a3b8;
  font-style: italic;
}

.no-logs i {
  margin-right: 0.5rem;
}

.test-stats {
  background: rgba(30, 41, 59, 0.5);
  border: 1px solid #475569;
  border-radius: 0.5rem;
  padding: 1.5rem;
}

.stats-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
  gap: 1.5rem;
}

.stat-item {
  text-align: center;
}

.stat-value {
  font-size: 2rem;
  font-weight: 700;
  color: #3b82f6;
  margin-bottom: 0.5rem;
}

.stat-label {
  font-size: 0.875rem;
  color: #94a3b8;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

/* Estilos para o Log de Eventos */
.event-summary {
  background: rgba(30, 41, 59, 0.5);
  border: 1px solid #475569;
  border-radius: 0.5rem;
  padding: 1.5rem;
}

.summary-stats {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 1rem;
  margin-bottom: 1.5rem;
}

.stat-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0.75rem;
  background: rgba(51, 65, 85, 0.3);
  border-radius: 0.375rem;
}

.stat-label {
  font-size: 0.875rem;
  color: #94a3b8;
  font-weight: 500;
}

.stat-value {
  font-size: 0.875rem;
  color: #e2e8f0;
  font-weight: 600;
}

.event-details {
  border-top: 1px solid #475569;
  padding-top: 1.5rem;
}

.event-details h4 {
  color: #e2e8f0;
  margin-bottom: 1rem;
  font-size: 1rem;
}

.event-detail-item {
  margin-bottom: 0.75rem;
  display: flex;
  align-items: flex-start;
  gap: 0.5rem;
}

.event-detail-item strong {
  color: #94a3b8;
  min-width: 80px;
  font-size: 0.875rem;
}

.event-data-preview {
  background: rgba(15, 23, 42, 0.8);
  border: 1px solid #475569;
  border-radius: 0.375rem;
  padding: 0.75rem;
  font-family: 'Courier New', monospace;
  font-size: 0.75rem;
  color: #e2e8f0;
  max-height: 200px;
  overflow-y: auto;
  margin: 0;
  flex: 1;
}

/* Estilos para Download */
.download-config {
  background: rgba(30, 41, 59, 0.5);
  border: 1px solid #475569;
  border-radius: 0.5rem;
  padding: 1.5rem;
  margin-bottom: 1.5rem;
}

.download-actions {
  display: flex;
  gap: 1rem;
  margin-top: 1.5rem;
  flex-wrap: wrap;
}

.download-status {
  background: rgba(30, 41, 59, 0.5);
  border: 1px solid #475569;
  border-radius: 0.5rem;
  padding: 1.5rem;
  margin-bottom: 1.5rem;
}

.download-terminal {
  background: rgba(15, 23, 42, 0.8);
  border: 1px solid #475569;
  border-radius: 0.5rem;
  overflow: hidden;
}

.log-entry.log-progress .log-type {
  color: #10b981;
}

.log-entry.log-progress .log-message {
  color: #10b981;
  font-weight: 500;
}
</style>